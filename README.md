The aim of this project is to develop a tool that can automatically convert pseudocode into Python code. This would really help make programming more approachable, especially for students and beginners who find it tough to write code from scratch. Instead of having to manually translate pseudocode, users would simply input their logic in a structured format and receive accurate Python code in return. 

The first step involves researching various styles of pseudocode. One of the biggest challenges will be ensuring the tool understands different logical structures, like loops and conditionals, while keeping the output clean and easy to read. Once the core translation process is up and running, testing will take center stage.

 The system needs to be able to handle a wide array of examples, including more complex logic, to guarantee accuracy. Another key aspect of the project is to make the tool user-friendly. A straightforward interface where users can input their pseudocode and instantly receive a Python equivalent would make it practical for real-world applications. Finally, improvements will be made based on the testing results, and documentation will be created to explain how everything works. By the end of the project, the goal is to have a reliable tool that assists students, educators, and even developers in saving time and reducing the effort needed to turn their ideas into functional code.


This project implements a pseudocode-to-Python compiler with a graphical user interface (GUI) that allows users to write pseudocode, compile it to Python, and execute the generated code. The system is designed as a multi-stage pipeline comprising lexical analysis, parsing, code generation, and execution.
1.	Lexical Analysis: The input pseudocode is tokenized using a custom lexer built with the ply (Python Lex-Yacc) library. The lexer identifies keywords (e.g., SET, IF, WHILE, FUNCTION), identifiers, literals, operators, and delimiters, transforming raw text into a stream of tokens.
2.	Parsing: Using ply.yacc, the token stream is fed into a grammar-defined parser that checks syntax and builds an abstract syntax tree (AST) or directly generates equivalent Python code. The grammar is designed to accommodate simplified English-like pseudocode statements, including variable assignment, control structures, and function definitions.
3.	Code Generation: The parser outputs Python code as a string, preserving program structure while converting pseudocode constructs into valid Python syntax.
4.	Execution: The generated Python code is executed within a sandboxed environment embedded in the GUI using Pythonâ€™s built-in exec() function. Standard output is captured via io.StringIO and displayed in the GUI.
5.	GUI and Communication: The user interface is built with tkinter, providing text areas for pseudocode input, Python output, and program execution results. User actions trigger translation and execution functions, communicating between GUI components and the compiler backend.
